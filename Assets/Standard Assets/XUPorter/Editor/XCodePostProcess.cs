using UnityEngine;
#if UNITY_EDITOR
using UnityEditor;
using UnityEditor.Callbacks;
using UnityEditor.XCodeEditor;
#endif
using System.IO;
using System.Collections.Generic;

public class XCodePostProcess: ScriptableObject
{
    public DefaultAsset m_entitlementsFile;

#if UNITY_EDITOR
	[PostProcessBuild(999)]
	public static void OnPostProcessBuild( BuildTarget target, string pathToBuiltProject )
	{
		if (target != BuildTarget.iOS) {
			//Debug.LogWarning("Target is not iPhone. XCodePostProcess will not run");
			return;
		}
        EditorIOSAutoBuild(pathToBuiltProject);

		//寰楀埌xcode宸ョ▼鐨勮矾寰兩		string path = Path.GetFullPath (pathToBuiltProject);

		// Create a new project object from build target
		XCProject project = new XCProject( pathToBuiltProject );

		// Find and run through all projmods files to patch the project.
		// Please pay attention that ALL projmods files in your project folder will be excuted!
		string[] files = Directory.GetFiles( Application.dataPath, "*.projmods", SearchOption.AllDirectories );

		foreach( string file in files ) {
			UnityEngine.Debug.Log("ProjMod File: "+file);
			project.ApplyMod( file );
		}

		//TODO implement generic settings as a module option
		project.overwriteBuildSetting("CODE_SIGN_IDENTITY[sdk=iphoneos*]", "iPhone Developer", "Release");

        string path = Path.GetFullPath(pathToBuiltProject);

        EditorPlist(path);
        EditShareSDKInfoPlist(path);
		//EditorCodeFixIOSInput (path);

        EditorTGPostBuild(project);
		// Finally save the xcode project
		project.Save();
	}
#endif

    private static void EditorPlist(string filePath){
        XCPlist list = new XCPlist(filePath);

        string PlistAdd = @"<key>CFBundleDevelopmentRegion</key>
                            <string>zh_CN</string>
                            <key>CFBundleAllowMixedLocalizations</key>
                            <true/>
                            <key>ITSAppUsesNonExemptEncryption</key>
                            <false/>";
        list.AddKey(PlistAdd);
        list.Save();
    }

    public static void Log(string message)
	{
		UnityEngine.Debug.Log("PostProcess: "+message);
	}
    private static void EditShareSDKInfoPlist(string projPath){

        XCPlist plist = new XCPlist (projPath);

        //URL Scheme 添加
        string PlistAdd = @"  
            <key>CFBundleURLTypes</key>
            <array>
                <dict>
                    <key>CFBundleURLSchemes</key>
                    <array>
                    <string>com.mob.demoShareSDK</string>
                    <string>rm226427com.mob.demoShareSDK</string>
                    <string>QQ41E5EF91</string>
                    <string>wx5b07442483553ba5</string>
                    <string>tencent100371282</string>
                    <string>wb568898243</string>
                    </array>
                </dict>
            </array>";

        //白名单添加
        string LSAdd = @"
        <key>LSApplicationQueriesSchemes</key>
            <array>
            <string>mqqopensdkapiV4</string>
            <string>weibosdk</string>
            <string>sinaweibohd</string>
            <string>sinaweibo</string>
           
            <string>rm226427com.mob.demoShareSDK</string>
            <string>mqq</string>
            <string>mqqopensdkapiV2</string>
            <string>mqqopensdkapiV3</string>
            <string>wtloginmqq2</string>
            <string>mqqapi</string>
            <string>mqqOpensdkSSoLogin</string>
            <string>sinaweibohdsso</string>
            <string>sinaweibosso</string>
            <string>wechat</string>
            <string>weixin</string>
        </array>";

        //ios10相关问题解决
        string ios10Add = @"
            <key>NSCameraUsageDescription</key>
            <string>装扮您的个人空间</string>
            <key>NSPhotoLibraryUsageDescription</key>
            <string>装扮您的个人空间</string>
            <key>NSMicrophoneUsageDescription</key>  
            <string>游戏内发语音</string>
            <key>NSCalendarsUsageDescription</key>
            <string>有些广告需要访问日历</string>
            <key>NSRemindersUsageDescription</key>
            <string>有些广告需要访问日历</string>
        ";  


        //在plist里面增加一行
        plist.AddKey(PlistAdd);
        plist.AddKey (LSAdd);
        plist.AddKey(ios10Add);
        plist.Save();
    }
        
    private static void EditorIOSAutoBuild(string buildPath)
    {
        #if UNITY_IOS
        var dummy = ScriptableObject.CreateInstance<XCodePostProcess>();
        var file = dummy.m_entitlementsFile;
        ScriptableObject.DestroyImmediate(dummy);
        if (file == null)
        {
            return;
        }

        var proj_path = UnityEditor.iOS.Xcode.PBXProject.GetPBXProjectPath(buildPath);
        var proj = new UnityEditor.iOS.Xcode.PBXProject();
        proj.ReadFromFile(proj_path);

        // target_name = "Unity-iPhone"
        var target_name = UnityEditor.iOS.Xcode.PBXProject.GetUnityTargetName();
        var target_guid = proj.TargetGuidByName(target_name);
        var src = AssetDatabase.GetAssetPath(file);
        var file_name = Path.GetFileName(src);
        var dst = buildPath + "/" + target_name + "/" + file_name;
        FileUtil.CopyFileOrDirectory(src, dst);
        proj.AddFile(target_name + "/" + file_name, file_name);
        proj.AddBuildProperty(target_guid, "CODE_SIGN_ENTITLEMENTS", target_name + "/" + file_name);

        proj.WriteToFile(proj_path);
        #endif
    }

	private static void EditorCodeFixIOSInput(string filePath)
	{
		//读取Keyboard.mm文件
		XClass UnityAppController = new XClass(filePath + "/Classes/UI/Keyboard.mm");
		UnityAppController.Replace ("#include \"Keyboard.h\"\n#include \"DisplayManager.h\"\n#include \"UnityForwardDecls.h\"\n#include <string>\n\n// Respect values passed from prefix header or CFlags\n#ifndef FILTER_EMOJIS_IOS_KEYBOARD \n// Set this flag to 0 in order to allow emoji symbols to be entered in the iOS keyboard.\n#define FILTER_EMOJIS_IOS_KEYBOARD 1\n#endif\n\nstatic KeyboardDelegate*\t_keyboard = nil;\n\nstatic bool\t\t\t\t\t_shouldHideInput = false;\nstatic bool\t\t\t\t\t_shouldHideInputChanged = false;\nstatic const unsigned\t\tkToolBarHeight = 64;\n\nenum KeyboardVisibleState {\n\tkPrepareToShow,  // Keyboard has been scheduled to become visible.\n\tkDidShow,  // Keyboard is visible.\n\tkPrepareToHide,  // Keyboard has been scheduled to hide.\n\tkDidHide  // Keyboard is hidden.\n};\n\n@interface KeyboardDelegate ()\n// This state is used to determine when the keyboard is active or not. The keyboard becomes active\n// as soon as it is scheduled to become visible (but before it's actually visible). We do this\n// because there was a bug where tapping on an InputField can cause back-to-back calls to\n// OnSelect() then OnDeselect() to happen.\n// What used to happen (the bug): If you tap on InputField A and enter some text, then tap on\n// InputField B in the same scene, you will see that InputField A receives the correct sequence\n// of OnDeselect(), TextDidEndEditing, etc. Then, you'll see InputField B get the correct\n// OnSelect() call, but then it gets an OnDeselect() call. This happened because the InputField\n// C# code looks at the active bit in the keyboard during a LateUpdate() cycle. At the time the\n// active bit is checked, the keyboard is in the middle of its hide / show cycle, and is temporarily\n// inactive.\n// The fix: using this state ivar decouples the existence of the keyboard view (and it's editView)\n// from whether the keyboard is active or not.\n@property (nonatomic) KeyboardVisibleState visibleState;\n@end\n\n@implementation KeyboardDelegate\n{\n\t// UI handling\n\t// in case of single line we use UITextField inside UIToolbar\n\t// in case of multi-line input we use UITextView with UIToolbar as accessory view\n\t// toolbar buttons are kept around to prevent releasing them\n\t// tvOS does not support multiline input thus only UITextField option is implemented\n#if UNITY_IOS\n\tUITextView*\t\ttextView;\n\n\tUIToolbar*\t\tviewToolbar;\n\tNSArray*\t\tviewToolbarItems;\n#endif\n\n\tUITextField*\ttextField;\n\n\t// keep toolbar items for both single- and multi- line edit in NSArray to make sure they are kept around\n#if UNITY_IOS\n\tUIToolbar*\t\tfieldToolbar;\n\tNSArray*\t\tfieldToolbarItems;\n#endif\n\n\t// inputView is view used for actual input (it will be responder): UITextField [single-line] or UITextView [multi-line]\n\t// editView is the \"root\" view for keyboard: UIToolbar [single-line] or UITextView [multi-line]\n\tUIView*\t\t\tinputView;\n\tUIView*\t\t\teditView;\n\n\n\tCGRect\t\t\t_area;\n\tNSString*\t\tinitialText;\n\n\tUIKeyboardType\tkeyboardType;\n\n\tBOOL\t\t\t_multiline;\n\tBOOL\t\t\t_inputHidden;\n\tBOOL\t\t\t_done;\n\tBOOL\t\t\t_canceled;\n\n\tBOOL\t\t\t_rotating;\n}\n\n@synthesize area;\n@synthesize done\t\t= _done;\n@synthesize canceled\t= _canceled;\n@synthesize text;\n\n// While emoji symbols are still shown in the iOS keyboard, they are all filtered by the\n// shouldChangeCharactersInRange method below.\n#if FILTER_EMOJIS_IOS_KEYBOARD\n\nbool stringContainsEmoji(NSString *string)\n{\n\t__block BOOL returnValue = NO;\n\t[string enumerateSubstringsInRange:NSMakeRange(0, [string length])\n\t\toptions:NSStringEnumerationByComposedCharacterSequences\n\t\tusingBlock: ^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop)\n\t\t{\n\t\t\tconst unichar hs = [substring characterAtIndex:0];\n\t\t\n\t\t\t// Surrogate pair\n\t\t\tif(hs >= 0xD800 && hs <= 0xDBFF)\n\t\t\t{\n\t\t\t\tif(substring.length > 1)\n\t\t\t\t{\n\t\t\t\t\t// Compute the code point in the U+10000 - U+10FFFF plane.\n\t\t\t\t\tconst unichar ls = [substring characterAtIndex:1];\n\t\t\t\t\tconst int uc = ((hs - 0xD800) * 0x400) + (ls - 0xDC00) + 0x10000;\n\t\t\t\t\n\t\t\t\t\t// The ranges for the various emoji tables are as follows.\n\t\t\t\t\t// Musical -> [U+1D000, U+1D24F]\n\t\t\t\t\t// Miscellaneous Symbols and Pictographs -> [U+1F300, U+1F5FF]\n\t\t\t\t\t// Emoticons -> [U+1F600, U+1F64F]\n\t\t\t\t\t// Transport and Map Symbols -> [U+1F680, U+1F6FF]\n\t\t\t\t\t// Supplemental Symbols and Pictographs -> [U+1F900, U+1F9FF]\n\t\t\t\t\tif(uc >= 0x1D000 && uc <= 0x1F9FF)\n\t\t\t\t\t{\n\t\t\t\t\t\treturnValue = YES;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(substring.length > 1)\n\t\t\t{\n\t\t\t\tconst unichar ls = [substring characterAtIndex:1];\n\t\t\t\n\t\t\t\tif(ls == 0x20E3)\n\t\t\t\t{\n\t\t\t\t\t// Filter all the emojis for numbers.\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t\telse if(hs >= 0x270A && hs <= 0x270D)\n\t\t\t\t{\n\t\t\t\t\t// Filter all the various hand symbols (e.g., victory sign, writing hand, etc).\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Non surrogate pair.\n\t\t\t\tif(hs >= 0x2100 && hs <= 0x27FF)\n\t\t\t\t{\n\t\t\t\t\t// Filter the following emoji ranges.\n\t\t\t\t\t// Letterlike Symbols -> [U+2100, U+214F]\n\t\t\t\t\t// Number Forms -> [U+2150, U+218F]\n\t\t\t\t\t// Arrows -> [U+2190, U+21FF]\n\t\t\t\t\t// Dingbats -> [U+2700, U+27BF]\n\t\t\t\t\t// Supplemental Arrows-A -> [U+27F0–U+27FF]\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t\telse if(hs >= 0x2900 && hs <= 0x297F)\n\t\t\t\t{\n\t\t\t\t\t// Filter Supplemental Arrows-B -> [U+2900, U+297F]\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t\telse if(hs >= 0x2B05 && hs <= 0x2BFF)\n\t\t\t\t{\n\t\t\t\t\t// Filter Miscellaneous Symbols and Arrows -> [U+2B00, U+2BFF]\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t}\n\t\t}];\n\t\n\treturn returnValue;\n}\n\n// See the documentation for this method in http://apple.co/1OMnz8D.\n-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string\n{\n\t// Process the input string using the 'stringContainsEmoji' function and return NO or YES\n\t// depending on whether it needs to be added to the UITexField or skipped altogether, respectively.\n\t// We need to do this because Unity's UI doesn't provide proper Unicode support yet.\n\treturn !stringContainsEmoji(string);\n}\n\n#endif // FILTER_EMOJIS_IOS_KEYBOARD\n\n- (BOOL)textFieldShouldReturn:(UITextField*)textFieldObj\n{\n\t[self hide];\n\treturn YES;\n}\n- (void)textInputDone:(id)sender\n{\n\t[self hide];\n}\n- (void)textInputCancel:(id)sender\n{\n\t_canceled = true;\n\t[self hide];\n}\n\n- (BOOL)textViewShouldBeginEditing:(UITextView*)view\n{\n#if !UNITY_TVOS\n\tview.inputAccessoryView = viewToolbar;\n#endif\n\treturn YES;\n}\n\n#if UNITY_IOS\n- (void)keyboardDidShow:(NSNotification*)notification\n{\n\tif (notification.userInfo == nil || inputView == nil)\n\t\treturn;\n\n\tCGRect srcRect\t= [[notification.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];\n\tCGRect rect\t\t= [UnityGetGLView() convertRect:srcRect fromView:nil];\n\n\t[self positionInput:rect x:rect.origin.x y:rect.origin.y];\n\tself.visibleState = kDidShow;\n}\n\n- (void)keyboardWillHide:(NSNotification*)notification\n{\n\t[self systemHideKeyboard];\n}\n\n- (void)keyboardDidHide:(NSNotification *)notification\n{\n\t// If the keyboard is currently scheduled to be shown, then don't change its\n\t// visible state here. This can happen when you change focus directly from one\n\t// input field to another one in the same scene. When you change focus in this way,\n\t// the C# code hides the keyboard when the first InputField loses focus (OnDeselect() is\n\t// called), and then it schedules the keyboard to be shown to be shown when the second\n\t// InputField receives focus (OnSelect() is called).  However, the notification that the\n\t// keyboard was hidden is received here *after* the C# code has scheduled the keyboard to\n\t// be shown. See the comment above the visibleState ivar for more information.\n\tif (self.visibleState != kPrepareToShow) {\n\t\tself.visibleState = kDidHide;\n\t}\n}\n\n- (void)keyboardDidChangeFrame:(NSNotification*)notification\n{\n\tCGRect srcRect\t= [[notification.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];\n\tCGRect rect\t\t= [UnityGetGLView() convertRect:srcRect fromView: nil];\n\n\tif(rect.origin.y >= [UnityGetGLView() bounds].size.height)\n\t\t[self systemHideKeyboard];\n\telse\n\t\t[self positionInput:rect x:rect.origin.x y:rect.origin.y];\n}\n#endif\n\n+ (void)Initialize\n{\n\tNSAssert(_keyboard == nil, @\"[KeyboardDelegate Initialize] called after creating keyboard\");\n\tif(!_keyboard)\n\t\t_keyboard = [[KeyboardDelegate alloc] init];\n}\n\n+ (KeyboardDelegate*)Instance\n{\n\tif(!_keyboard)\n\t\t_keyboard = [[KeyboardDelegate alloc] init];\n\treturn _keyboard;\n}\n\n#if UNITY_IOS\nstruct CreateToolbarResult\n{\n\tUIToolbar*\ttoolbar;\n\tNSArray*\titems;\n};\n- (CreateToolbarResult)createToolbarWithView:(UIView*)view\n{\n\tUIToolbar* toolbar = [[UIToolbar alloc] initWithFrame:CGRectMake(0,160,320, kToolBarHeight)];\n\tUnitySetViewTouchProcessing(toolbar, touchesIgnored);\n\ttoolbar.hidden = NO;\n\n\tUIBarButtonItem* inputItem\t= view ? [[UIBarButtonItem alloc] initWithCustomView:view] : nil;\n\tUIBarButtonItem* doneItem\t= [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone target:self action:@selector(textInputDone:)];\n\tUIBarButtonItem* cancelItem\t= [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemCancel target:self action:@selector(textInputCancel:)];\n\n\tNSArray* items = view ? @[inputItem, doneItem, cancelItem] : @[doneItem, cancelItem];\n\ttoolbar.items = items;\n\n\tinputItem = nil;\n\tdoneItem = nil;\n\tcancelItem = nil;\n\n\tCreateToolbarResult ret = {toolbar, items};\n\treturn ret;\n}\n#endif\n\n- (id)init\n{\n\tNSAssert(_keyboard == nil, @\"You can have only one instance of KeyboardDelegate\");\n\tself = [super init];\n\tif(self)\n\t{\n#if UNITY_IOS\n\t\ttextView = [[UITextView alloc] initWithFrame:CGRectMake(0, 480, 480, 30)];\n\t\ttextView.delegate = self;\n\t\ttextView.font = [UIFont systemFontOfSize:18.0];\n\t\ttextView.hidden = YES;\n#endif\n\n\t\ttextField = [[UITextField alloc] initWithFrame:CGRectMake(0,0,120,30)];\n\t\ttextField.delegate = self;\n\t\ttextField.borderStyle = UITextBorderStyleRoundedRect;\n\t\ttextField.font = [UIFont systemFontOfSize:20.0];\n\t\ttextField.clearButtonMode = UITextFieldViewModeWhileEditing;\n\n\t\t#define CREATE_TOOLBAR(t, i, v)\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tCreateToolbarResult res = [self createToolbarWithView:v];\t\\\n\t\t\tt = res.toolbar;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = res.items;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} while(0)\n\n#if UNITY_IOS\n\t\tCREATE_TOOLBAR(viewToolbar, viewToolbarItems, nil);\n\t\tCREATE_TOOLBAR(fieldToolbar, fieldToolbarItems, textField);\n#endif\n\n\t\t#undef CREATE_TOOLBAR\n\n#if UNITY_IOS\n\t\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidShow:) name:UIKeyboardDidShowNotification object:nil];\n\t\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];\n\t\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidHide:) name:UIKeyboardDidHideNotification object:nil];\n\t\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidChangeFrame:) name:UIKeyboardDidChangeFrameNotification object:nil];\n#endif\n\t\t\n\t\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textInputDone:) name:UITextFieldTextDidEndEditingNotification object:nil];\n\t}\n\n\treturn self;\n}\n\n- (BOOL)active {\n\t// The keyboard is active when it is in an active state (either it is about to be shown, or it\n\t// is currently shown), OR when the edit view is hte first responder. Checking the first\n\t// responder bit is necessary because the suggestion list for some multi-byte languages can take over\n\t// the entire screen, which renders the keyboard temporarily invisble.\n\treturn self.visibleState == kPrepareToShow || self.visibleState == kDidShow || editView.isFirstResponder;\n}\n\n- (void) setTextInputTraits: (id<UITextInputTraits>) traits\n\t\t\t\t  withParam: (KeyboardShowParam) param\n\t\t\t\t\twithCap: (UITextAutocapitalizationType) capitalization\n{\n\ttraits.keyboardType\t= param.keyboardType;\n\ttraits.autocorrectionType = param.autocorrectionType;\n\ttraits.secureTextEntry = param.secure;\n\ttraits.keyboardAppearance = param.appearance;\n\ttraits.autocapitalizationType = capitalization;\n}\n\n- (void)setKeyboardParams:(KeyboardShowParam)param\n{\n\tif(self.active)\n\t\t[self hide];\n\n\tinitialText = param.text ? [[NSString alloc] initWithUTF8String: param.text] : @\"\";\n\n\tUITextAutocapitalizationType capitalization = UITextAutocapitalizationTypeSentences;\n\tif(param.keyboardType == UIKeyboardTypeURL || param.keyboardType == UIKeyboardTypeEmailAddress)\n\t\tcapitalization = UITextAutocapitalizationTypeNone;\n\n#if UNITY_IOS\n\t_multiline = param.multiline;\n\tif (_multiline)\n\t{\n\t\ttextView.text = initialText;\n\t\t[self setTextInputTraits:textView withParam:param withCap:capitalization];\n\t}\n\telse\n\t{\n\t\ttextField.text = initialText;\n\t\t[self setTextInputTraits:textField withParam:param withCap:capitalization];\n\t\ttextField.placeholder = [NSString stringWithUTF8String:param.placeholder];\n\t}\n\tinputView = _multiline ? textView : textField;\n\teditView = _multiline ? textView : fieldToolbar;\n\n#else // UNITY_TVOS\n\ttextField.text = initialText;\n\t[self setTextInputTraits:textField withParam:param withCap:capitalization];\n\ttextField.placeholder = [NSString stringWithUTF8String:param.placeholder];\n\tinputView = textField;\n\teditView = textField;\n#endif\n\n\t[self shouldHideInput:_shouldHideInput];\n\n\t_done\t\t= NO;\n\t_canceled\t= NO;\n}\n\n// we need to show/hide keyboard to react to orientation too, so extract we extract UI fiddling\n\n- (void)showUI\n{\n\t// if we unhide everything now the input will be shown smaller then needed quickly (and resized later)\n\t// so unhide only when keyboard is actually shown (we will update it when reacting to ios notifications)\n\teditView.hidden = YES;\n\n\t[UnityGetGLView() addSubview:editView];\n\t[inputView becomeFirstResponder];\n}\n- (void)hideUI\n{\n\tself.visibleState = kPrepareToHide;\n\t[inputView resignFirstResponder];\n\n\t[editView removeFromSuperview];\n\teditView.hidden = YES;\n}\n- (void)systemHideKeyboard\n{\n\t// It's possible that the keyboard goes through a hide / show cycle even though it\n\t// should remain active. For example, when changing focus between InputFields by\n\t// tapping (see comment above regarding the visibleState ivar). For this reason,\n\t// do not change visibleState in this method.\n\n\teditView.hidden = YES;\n\n\t_area = CGRectMake(0,0,0,0);\n}\n\n- (void)show\n{\n\t[self showUI];\n}\n- (void)hide\n{\n\t[self hideUI];\n\t_done = YES;\n}\n\n- (void)updateInputHidden\n{\n\tif(_shouldHideInputChanged)\n\t{\n\t\t[self shouldHideInput:_shouldHideInput];\n\t\t_shouldHideInputChanged = false;\n\t}\n\n\ttextField.returnKeyType = _inputHidden ? UIReturnKeyDone : UIReturnKeyDefault;\n\n\teditView.hidden\t\t= _inputHidden ? YES : NO;\n\tinputView.hidden\t= _inputHidden ? YES : NO;\n}\n\n#if UNITY_IOS\n- (void)positionInput:(CGRect)kbRect x:(float)x y:(float)y\n{\n\tif(_multiline)\n\t{\n\t\t// use smaller area for iphones and bigger one for ipads\n\t\tint height = UnityDeviceDPI() > 300 ? 75 : 100;\n\n\t\teditView.frame\t= CGRectMake(0, y - kToolBarHeight, kbRect.size.width, height);\n\t}\n\telse\n\t{\n\t\tCGRect   statusFrame\t= [UIApplication sharedApplication].statusBarFrame;\n\t\tunsigned statusHeight\t= statusFrame.size.height;\n\n\t\teditView.frame\t= CGRectMake(0, y - kToolBarHeight - statusHeight, kbRect.size.width, kToolBarHeight);\n        inputView.frame\t= CGRectMake(inputView.frame.origin.x,\n                                     inputView.frame.origin.y,\n                                     kbRect.size.width - 3*18 - 2*50,\n                                     inputView.frame.size.height);\n\t}\n\n\t_area = CGRectMake(x, y, kbRect.size.width, kbRect.size.height);\n\t[self updateInputHidden];\n}\n#endif\n\n- (CGRect)queryArea\n{\n\treturn editView.hidden ? _area : CGRectUnion(_area, editView.frame);\n}\n\n+ (void)StartReorientation\n{\n\tif(_keyboard && _keyboard.active)\n\t{\n\t\t[CATransaction begin];\n\t\t[_keyboard hideUI];\n\t\t[CATransaction commit];\n\n\t\t// not pretty but seems like easiest way to keep \"we are rotating\" status\n\t\t_keyboard->_rotating = YES;\n\t}\n}\n\n+ (void)FinishReorientation\n{\n\tif(_keyboard && _keyboard->_rotating)\n\t{\n\t\t[CATransaction begin];\n\t\t[_keyboard showUI];\n\t\t[CATransaction commit];\n\n\t\t_keyboard->_rotating = NO;\n\t}\n}\n\n- (NSString*)getText\n{\n\tif (_canceled)\n\t\treturn initialText;\n\telse\n\t{\n#if UNITY_TVOS\n\t\treturn [textField text];\n#else\n\t\treturn _multiline ? [textView text] : [textField text];\n#endif\n\t}\n}\n\n- (void) setTextWorkaround:(id<UITextInput>)textInput text:(NSString*)newText\n{\n\tUITextPosition* begin = [textInput beginningOfDocument];\n\tUITextPosition* end = [textInput endOfDocument];\n\tUITextRange* allText = [textInput textRangeFromPosition:begin toPosition:end];\n\t[textInput setSelectedTextRange:allText];\n\t[textInput insertText:newText];\n}\n\n- (void)setText:(NSString*)newText\n{\n#if UNITY_IOS\n\t// We can't use setText on iOS7 because it does not update the undo stack.\n\t// We still prefer setText on other iOSes, because an undo operation results\n\t// in a smaller selection shown on the UI\n\tif(_ios70orNewer && !_ios80orNewer)\n\t\t[self setTextWorkaround: (_multiline ? textView : textField) text:newText];\n\n\tif(_multiline)\n\t\ttextView.text = newText;\n\telse\n\t\ttextField.text = newText;\n#else\n\ttextField.text = newText;\n#endif\n}\n\n- (void)shouldHideInput:(BOOL)hide\n{\n\tif(hide)\n\t{\n\t\tswitch(keyboardType)\n\t\t{\n\t\t\tcase UIKeyboardTypeDefault:                 hide = YES;\tbreak;\n\t\t\tcase UIKeyboardTypeASCIICapable:            hide = YES;\tbreak;\n\t\t\tcase UIKeyboardTypeNumbersAndPunctuation:   hide = YES;\tbreak;\n\t\t\tcase UIKeyboardTypeURL:                     hide = YES;\tbreak;\n\t\t\tcase UIKeyboardTypeNumberPad:               hide = NO;\tbreak;\n\t\t\tcase UIKeyboardTypePhonePad:                hide = NO;\tbreak;\n\t\t\tcase UIKeyboardTypeNamePhonePad:            hide = NO;\tbreak;\n\t\t\tcase UIKeyboardTypeEmailAddress:            hide = YES;\tbreak;\n\t\t\tdefault:                                    hide = NO;\tbreak;\n\t\t}\n\t}\n\n\t_inputHidden = hide;\n}\n\n@end\n\n\n\n//==============================================================================\n//\n//  Unity Interface:\n\nextern \"C\" void UnityKeyboard_Create(unsigned keyboardType, int autocorrection, int multiline, int secure, int alert, const char* text, const char* placeholder)\n{\n#if UNITY_TVOS\n\t// Not supported. The API for showing keyboard for editing multi-line text\n\t// is not available on tvOS\n\tmultiline = false;\n#endif\n\t\n\tstatic const UIKeyboardType keyboardTypes[] =\n\t{\n\t\tUIKeyboardTypeDefault,\n\t\tUIKeyboardTypeASCIICapable,\n\t\tUIKeyboardTypeNumbersAndPunctuation,\n\t\tUIKeyboardTypeURL,\n\t\tUIKeyboardTypeNumberPad,\n\t\tUIKeyboardTypePhonePad,\n\t\tUIKeyboardTypeNamePhonePad,\n\t\tUIKeyboardTypeEmailAddress,\n\t};\n\n\tstatic const UITextAutocorrectionType autocorrectionTypes[] =\n\t{\n\t\tUITextAutocorrectionTypeNo,\n\t\tUITextAutocorrectionTypeDefault,\n\t};\n\n\tstatic const UIKeyboardAppearance keyboardAppearances[] =\n\t{\n\t\tUIKeyboardAppearanceDefault,\n\t\tUIKeyboardAppearanceAlert,\n\t};\n\n\tKeyboardShowParam param =\n\t{\n\t\ttext, placeholder,\n\t\tkeyboardTypes[keyboardType],\n\t\tautocorrectionTypes[autocorrection],\n\t\tkeyboardAppearances[alert],\n\t\t(BOOL)multiline, (BOOL)secure\n\t};\n\n\t[[KeyboardDelegate Instance] setKeyboardParams:param];\n}\n\nextern \"C\" void UnityKeyboard_PrepareToShow()\n{\n\t[KeyboardDelegate Instance].visibleState = kPrepareToShow;\n}\n\nextern \"C\" void UnityKeyboard_Show()\n{\n\t// do not send hide if didnt create keyboard\n\t// TODO: probably assert?\n\tif(!_keyboard)\n\t\treturn;\n\n\t[[KeyboardDelegate Instance] show];\n}\n\nextern \"C\" void UnityKeyboard_Hide()\n{\n\t// do not send hide if didnt create keyboard\n\t// TODO: probably assert?\n\tif(!_keyboard)\n\t\treturn;\n\n\t[[KeyboardDelegate Instance] hide];\n}\n\nextern \"C\" void UnityKeyboard_SetText(const char* text)\n{\n\t[KeyboardDelegate Instance].text = [NSString stringWithUTF8String: text];\n}\n\nextern \"C\" NSString* UnityKeyboard_GetText()\n{\n\treturn [KeyboardDelegate Instance].text;\n}\n\nextern \"C\" int UnityKeyboard_IsActive()\n{\n\treturn (_keyboard && _keyboard.active) ? 1 : 0;\n}\n\nextern \"C\" int UnityKeyboard_IsDone()\n{\n\treturn (_keyboard && _keyboard.done) ? 1 : 0;\n}\n\nextern \"C\" int UnityKeyboard_WasCanceled()\n{\n\treturn (_keyboard && _keyboard.canceled) ? 1 : 0;\n}\n\nextern \"C\" void UnityKeyboard_SetInputHidden(int hidden)\n{\n\t_shouldHideInput\t\t= hidden;\n\t_shouldHideInputChanged\t= true;\n\n\t// update hidden status only if keyboard is on screen to avoid showing input view out of nowhere\n\tif(_keyboard && _keyboard.active)\n\t\t[_keyboard updateInputHidden];\n}\n\nextern \"C\" int UnityKeyboard_IsInputHidden()\n{\n\treturn _shouldHideInput ? 1 : 0;\n}\n\nextern \"C\" void UnityKeyboard_GetRect(float* x, float* y, float* w, float* h)\n{\n\tCGRect area = _keyboard ? _keyboard.area : CGRectMake(0,0,0,0);\n\n\t// convert to unity coord system\n\n\tfloat\tmultX\t= (float)GetMainDisplaySurface()->targetW / UnityGetGLView().bounds.size.width;\n\tfloat\tmultY\t= (float)GetMainDisplaySurface()->targetH / UnityGetGLView().bounds.size.height;\n\n\t*x = 0;\n\t*y = area.origin.y * multY;\n\t*w = area.size.width * multX;\n\t*h = area.size.height * multY;\n}\n"
			,
			"#include \"Keyboard.h\"\n#include \"DisplayManager.h\"\n#include \"UnityForwardDecls.h\"\n#include <string>\n\n// Respect values passed from prefix header or CFlags\n#ifndef FILTER_EMOJIS_IOS_KEYBOARD \n// Set this flag to 0 in order to allow emoji symbols to be entered in the iOS keyboard.\n#define FILTER_EMOJIS_IOS_KEYBOARD 1\n#endif\n\nstatic KeyboardDelegate*\t_keyboard = nil;\n\nstatic bool\t\t\t\t\t_shouldHideInput = false;\nstatic bool\t\t\t\t\t_shouldHideInputChanged = false;\nstatic const unsigned\t\tkToolBarHeight = 64;\n\nenum KeyboardVisibleState {\n\tkPrepareToShow,  // Keyboard has been scheduled to become visible.\n\tkDidShow,  // Keyboard is visible.\n\tkPrepareToHide,  // Keyboard has been scheduled to hide.\n\tkDidHide  // Keyboard is hidden.\n};\n\n@interface KeyboardDelegate ()\n// This state is used to determine when the keyboard is active or not. The keyboard becomes active\n// as soon as it is scheduled to become visible (but before it's actually visible). We do this\n// because there was a bug where tapping on an InputField can cause back-to-back calls to\n// OnSelect() then OnDeselect() to happen.\n// What used to happen (the bug): If you tap on InputField A and enter some text, then tap on\n// InputField B in the same scene, you will see that InputField A receives the correct sequence\n// of OnDeselect(), TextDidEndEditing, etc. Then, you'll see InputField B get the correct\n// OnSelect() call, but then it gets an OnDeselect() call. This happened because the InputField\n// C# code looks at the active bit in the keyboard during a LateUpdate() cycle. At the time the\n// active bit is checked, the keyboard is in the middle of its hide / show cycle, and is temporarily\n// inactive.\n// The fix: using this state ivar decouples the existence of the keyboard view (and it's editView)\n// from whether the keyboard is active or not.\n@property (nonatomic) KeyboardVisibleState visibleState;\n@end\n\n@implementation KeyboardDelegate\n{\n\t// UI handling\n\t// in case of single line we use UITextField inside UIToolbar\n\t// in case of multi-line input we use UITextView with UIToolbar as accessory view\n\t// toolbar buttons are kept around to prevent releasing them\n\t// tvOS does not support multiline input thus only UITextField option is implemented\n#if UNITY_IOS\n\tUITextView*\t\ttextView;\n\n\tUIToolbar*\t\tviewToolbar;\n\tNSArray*\t\tviewToolbarItems;\n#endif\n\n\tUITextField*\ttextField;\n\n\t// keep toolbar items for both single- and multi- line edit in NSArray to make sure they are kept around\n#if UNITY_IOS\n\tUIToolbar*\t\tfieldToolbar;\n\tNSArray*\t\tfieldToolbarItems;\n#endif\n\n\t// inputView is view used for actual input (it will be responder): UITextField [single-line] or UITextView [multi-line]\n\t// editView is the \"root\" view for keyboard: UIToolbar [single-line] or UITextView [multi-line]\n\tUIView*\t\t\tinputView;\n\tUIView*\t\t\teditView;\n\n\n\tCGRect\t\t\t_area;\n\tNSString*\t\tinitialText;\n\n\tUIKeyboardType\tkeyboardType;\n\n\tBOOL\t\t\t_multiline;\n\tBOOL\t\t\t_inputHidden;\n\tBOOL\t\t\t_active;\n\tBOOL\t\t\t_done;\n\tBOOL\t\t\t_canceled;\n\n\tBOOL\t\t\t_rotating;\n}\n\n@synthesize area;\n@synthesize active\t\t= _active;\n@synthesize done\t\t= _done;\n@synthesize canceled\t= _canceled;\n@synthesize text;\n\n// While emoji symbols are still shown in the iOS keyboard, they are all filtered by the\n// shouldChangeCharactersInRange method below.\n#if FILTER_EMOJIS_IOS_KEYBOARD\n\nbool stringContainsEmoji(NSString *string)\n{\n\t__block BOOL returnValue = NO;\n\t[string enumerateSubstringsInRange:NSMakeRange(0, [string length])\n\t\toptions:NSStringEnumerationByComposedCharacterSequences\n\t\tusingBlock: ^(NSString *substring, NSRange substringRange, NSRange enclosingRange, BOOL *stop)\n\t\t{\n\t\t\tconst unichar hs = [substring characterAtIndex:0];\n\t\t\n\t\t\t// Surrogate pair\n\t\t\tif(hs >= 0xD800 && hs <= 0xDBFF)\n\t\t\t{\n\t\t\t\tif(substring.length > 1)\n\t\t\t\t{\n\t\t\t\t\t// Compute the code point in the U+10000 - U+10FFFF plane.\n\t\t\t\t\tconst unichar ls = [substring characterAtIndex:1];\n\t\t\t\t\tconst int uc = ((hs - 0xD800) * 0x400) + (ls - 0xDC00) + 0x10000;\n\t\t\t\t\n\t\t\t\t\t// The ranges for the various emoji tables are as follows.\n\t\t\t\t\t// Musical -> [U+1D000, U+1D24F]\n\t\t\t\t\t// Miscellaneous Symbols and Pictographs -> [U+1F300, U+1F5FF]\n\t\t\t\t\t// Emoticons -> [U+1F600, U+1F64F]\n\t\t\t\t\t// Transport and Map Symbols -> [U+1F680, U+1F6FF]\n\t\t\t\t\t// Supplemental Symbols and Pictographs -> [U+1F900, U+1F9FF]\n\t\t\t\t\tif(uc >= 0x1D000 && uc <= 0x1F9FF)\n\t\t\t\t\t{\n\t\t\t\t\t\treturnValue = YES;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(substring.length > 1)\n\t\t\t{\n\t\t\t\tconst unichar ls = [substring characterAtIndex:1];\n\t\t\t\n\t\t\t\tif(ls == 0x20E3)\n\t\t\t\t{\n\t\t\t\t\t// Filter all the emojis for numbers.\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t\telse if(hs >= 0x270A && hs <= 0x270D)\n\t\t\t\t{\n\t\t\t\t\t// Filter all the various hand symbols (e.g., victory sign, writing hand, etc).\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// Non surrogate pair.\n\t\t\t\tif(hs >= 0x2100 && hs <= 0x27FF)\n\t\t\t\t{\n\t\t\t\t\t// Filter the following emoji ranges.\n\t\t\t\t\t// Letterlike Symbols -> [U+2100, U+214F]\n\t\t\t\t\t// Number Forms -> [U+2150, U+218F]\n\t\t\t\t\t// Arrows -> [U+2190, U+21FF]\n\t\t\t\t\t// Dingbats -> [U+2700, U+27BF]\n\t\t\t\t\t// Supplemental Arrows-A -> [U+27F0–U+27FF]\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t\telse if(hs >= 0x2900 && hs <= 0x297F)\n\t\t\t\t{\n\t\t\t\t\t// Filter Supplemental Arrows-B -> [U+2900, U+297F]\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t\telse if(hs >= 0x2B05 && hs <= 0x2BFF)\n\t\t\t\t{\n\t\t\t\t\t// Filter Miscellaneous Symbols and Arrows -> [U+2B00, U+2BFF]\n\t\t\t\t\treturnValue = YES;\n\t\t\t\t}\n\t\t\t}\n\t\t}];\n\t\n\treturn returnValue;\n}\n\n// See the documentation for this method in http://apple.co/1OMnz8D.\n-(BOOL)textField:(UITextField *)textField shouldChangeCharactersInRange:(NSRange)range replacementString:(NSString *)string\n{\n\t// Process the input string using the 'stringContainsEmoji' function and return NO or YES\n\t// depending on whether it needs to be added to the UITexField or skipped altogether, respectively.\n\t// We need to do this because Unity's UI doesn't provide proper Unicode support yet.\n\treturn !stringContainsEmoji(string);\n}\n\n#endif // FILTER_EMOJIS_IOS_KEYBOARD\n\n- (BOOL)textView:(UITextView *)textView shouldChangeTextInRange:(NSRange)range replacementText:(NSString *)text{\n    if ([text isEqualToString:@\"\\n\"]){\n        //判断输入的字是否是回车，即按下return\n        //在这里做你响应return键的代码\n        [self hide];\n        return NO; //这里返回NO，就代表return键值失效，即页面上按下return，不会出现换行，如果为yes，则输入页面会换行\n    }\n    return YES;\n}\n\n- (BOOL)textViewShouldReturn:(UITextView*)textFieldObj\n{\n    [self hide];\n    return YES;\n}\n\n- (BOOL)textFieldShouldReturn:(UITextField*)textFieldObj\n{\n\t[self hide];\n\treturn YES;\n}\n- (void)textInputDone:(id)sender\n{\n\t[self hide];\n}\n- (void)textInputCancel:(id)sender\n{\n\t_canceled = true;\n\t[self hide];\n}\n\n- (BOOL)textViewShouldBeginEditing:(UITextView*)view\n{\n#if !UNITY_TVOS\n\tview.inputAccessoryView = viewToolbar;\n#endif\n\treturn YES;\n}\n\n#if UNITY_IOS\n- (void)keyboardDidShow:(NSNotification*)notification\n{\n\tif (notification.userInfo == nil || inputView == nil)\n\t\treturn;\n\n\tCGRect srcRect\t= [[notification.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];\n\tCGRect rect\t\t= [UnityGetGLView() convertRect:srcRect fromView:nil];\n\n\t[self positionInput:rect x:rect.origin.x y:rect.origin.y];\n\t_active = YES;\n}\n\n- (void)keyboardWillHide:(NSNotification*)notification\n{\n\t[self systemHideKeyboard];\n}\n- (void)keyboardDidChangeFrame:(NSNotification*)notification;\n{\n\t_active = true;\n\n\tCGRect srcRect\t= [[notification.userInfo objectForKey:UIKeyboardFrameEndUserInfoKey] CGRectValue];\n\tCGRect rect\t\t= [UnityGetGLView() convertRect:srcRect fromView: nil];\n\n\tif(rect.origin.y >= [UnityGetGLView() bounds].size.height)\n\t\t[self systemHideKeyboard];\n\telse\n\t\t[self positionInput:rect x:rect.origin.x y:rect.origin.y];\n}\n#endif\n\n+ (void)Initialize\n{\n\tNSAssert(_keyboard == nil, @\"[KeyboardDelegate Initialize] called after creating keyboard\");\n\tif(!_keyboard)\n\t\t_keyboard = [[KeyboardDelegate alloc] init];\n}\n\n+ (KeyboardDelegate*)Instance\n{\n\tif(!_keyboard)\n\t\t_keyboard = [[KeyboardDelegate alloc] init];\n\treturn _keyboard;\n}\n\n#if UNITY_IOS\nstruct CreateToolbarResult\n{\n\tUIToolbar*\ttoolbar;\n\tNSArray*\titems;\n};\n- (CreateToolbarResult)createToolbarWithView:(UIView*)view\n{\n\tUIToolbar* toolbar = [[UIToolbar alloc] initWithFrame:CGRectMake(0,160,320, kToolBarHeight)];\n\tUnitySetViewTouchProcessing(toolbar, touchesIgnored);\n\ttoolbar.hidden = NO;\n\n\tUIBarButtonItem* inputItem\t= view ? [[UIBarButtonItem alloc] initWithCustomView:view] : nil;\n\tUIBarButtonItem* doneItem\t= [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemDone target:self action:@selector(textInputDone:)];\n\tUIBarButtonItem* cancelItem\t= [[UIBarButtonItem alloc] initWithBarButtonSystemItem:UIBarButtonSystemItemCancel target:self action:@selector(textInputCancel:)];\n\n\tNSArray* items = view ? @[inputItem, doneItem, cancelItem] : @[doneItem, cancelItem];\n\ttoolbar.items = items;\n\n\tinputItem = nil;\n\tdoneItem = nil;\n\tcancelItem = nil;\n\n\tCreateToolbarResult ret = {toolbar, items};\n\treturn ret;\n}\n#endif\n\n- (id)init\n{\n\tNSAssert(_keyboard == nil, @\"You can have only one instance of KeyboardDelegate\");\n\tself = [super init];\n\tif(self)\n\t{\n#if UNITY_IOS\n\t\ttextView = [[UITextView alloc] initWithFrame:CGRectMake(0, 480, 480, 30)];\n\t\ttextView.delegate = self;\n\t\ttextView.font = [UIFont systemFontOfSize:18.0];\n\t\ttextView.hidden = YES;\n        textView.returnKeyType = UIReturnKeyDone;\n\n#endif\n\n\t\ttextField = [[UITextField alloc] initWithFrame:CGRectMake(0,0,120,30)];\n\t\ttextField.delegate = self;\n\t\ttextField.borderStyle = UITextBorderStyleRoundedRect;\n\t\ttextField.font = [UIFont systemFontOfSize:20.0];\n\t\ttextField.clearButtonMode = UITextFieldViewModeWhileEditing;\n\n\t\t#define CREATE_TOOLBAR(t, i, v)\t\t\t\t\t\t\t\t\t\\\n\t\tdo {\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\tCreateToolbarResult res = [self createToolbarWithView:v];\t\\\n\t\t\tt = res.toolbar;\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t\ti = res.items;\t\t\t\t\t\t\t\t\t\t\t\t\\\n\t\t} while(0)\n\n#if UNITY_IOS\n\t\t//CREATE_TOOLBAR(viewToolbar, viewToolbarItems, nil);\n\t\tCREATE_TOOLBAR(fieldToolbar, fieldToolbarItems, textField);\n#endif\n\n\t\t#undef CREATE_TOOLBAR\n\n#if UNITY_IOS\n\t\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidShow:) name:UIKeyboardDidShowNotification object:nil];\n\t\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillHide:) name:UIKeyboardWillHideNotification object:nil];\n\t\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardDidChangeFrame:) name:UIKeyboardDidChangeFrameNotification object:nil];\n#endif\n\t\t\n\t\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(textInputDone:) name:UITextFieldTextDidEndEditingNotification object:nil];\n\t}\n\n\treturn self;\n}\n\n- (void) setTextInputTraits: (id<UITextInputTraits>) traits\n\t\t\t\t  withParam: (KeyboardShowParam) param\n\t\t\t\t\twithCap: (UITextAutocapitalizationType) capitalization\n{\n\ttraits.keyboardType\t= param.keyboardType;\n\ttraits.autocorrectionType = param.autocorrectionType;\n\ttraits.secureTextEntry = param.secure;\n\ttraits.keyboardAppearance = param.appearance;\n\ttraits.autocapitalizationType = capitalization;\n}\n\n- (void)setKeyboardParams:(KeyboardShowParam)param\n{\n\tif(_active)\n\t\t[self hide];\n\n\tinitialText = param.text ? [[NSString alloc] initWithUTF8String: param.text] : @\"\";\n\n\tUITextAutocapitalizationType capitalization = UITextAutocapitalizationTypeSentences;\n\tif(param.keyboardType == UIKeyboardTypeURL || param.keyboardType == UIKeyboardTypeEmailAddress)\n\t\tcapitalization = UITextAutocapitalizationTypeNone;\n\n#if UNITY_IOS\n//\t_multiline = param.multiline;\n    _multiline = true;\n\n\tif (_multiline)\n\t{\n\t\ttextView.text = initialText;\n\t\t[self setTextInputTraits:textView withParam:param withCap:capitalization];\n\t}\n\telse\n\t{\n\t\ttextField.text = initialText;\n\t\t[self setTextInputTraits:textField withParam:param withCap:capitalization];\n\t\ttextField.placeholder = [NSString stringWithUTF8String:param.placeholder];\n\t}\n\tinputView = _multiline ? textView : textField;\n\teditView = _multiline ? textView : fieldToolbar;\n\n#else // UNITY_TVOS\n\ttextField.text = initialText;\n\t[self setTextInputTraits:textField withParam:param withCap:capitalization];\n\ttextField.placeholder = [NSString stringWithUTF8String:param.placeholder];\n\tinputView = textField;\n\teditView = textField;\n#endif\n\n\t[self shouldHideInput:_shouldHideInput];\n\n\t_done\t\t= NO;\n\t_canceled\t= NO;\n\t_active\t\t= YES;\n}\n\n// we need to show/hide keyboard to react to orientation too, so extract we extract UI fiddling\n\n- (void)showUI\n{\n\t// if we unhide everything now the input will be shown smaller then needed quickly (and resized later)\n\t// so unhide only when keyboard is actually shown (we will update it when reacting to ios notifications)\n\teditView.hidden = YES;\n\n\t[UnityGetGLView() addSubview:editView];\n\t[inputView becomeFirstResponder];\n}\n- (void)hideUI\n{\n\t[inputView resignFirstResponder];\n\n\t[editView removeFromSuperview];\n\teditView.hidden = YES;\n}\n- (void)systemHideKeyboard\n{\n\t_active = editView.isFirstResponder;\n\teditView.hidden = YES;\n\n\t_area = CGRectMake(0,0,0,0);\n}\n\n- (void)show\n{\n\t[self showUI];\n}\n- (void)hide\n{\n\t[self hideUI];\n\t_done = YES;\n}\n\n- (void)updateInputHidden\n{\n\tif(_shouldHideInputChanged)\n\t{\n\t\t[self shouldHideInput:_shouldHideInput];\n\t\t_shouldHideInputChanged = false;\n\t}\n\n\ttextField.returnKeyType = _inputHidden ? UIReturnKeyDone : UIReturnKeyDefault;\n\n\teditView.hidden\t\t= _inputHidden ? YES : NO;\n\tinputView.hidden\t= _inputHidden ? YES : NO;\n}\n\n#if UNITY_IOS\n- (void)positionInput:(CGRect)kbRect x:(float)x y:(float)y\n{\n\tif(_multiline)\n\t{\n\t\t// use smaller area for iphones and bigger one for ipads\n\t\t//int height = UnityDeviceDPI() > 300 ? 75 : 100;\n\n\t\t//editView.frame\t= CGRectMake(0, y - kToolBarHeight, kbRect.size.width, height);\n        int height = UnityDeviceDPI() > 300 ? 38 : 100;\n        editView.frame\t= CGRectMake(0, y - height, kbRect.size.width, height);\n\t}\n\telse\n\t{\n\t\tCGRect   statusFrame\t= [UIApplication sharedApplication].statusBarFrame;\n\t\tunsigned statusHeight\t= statusFrame.size.height;\n\n\t\teditView.frame\t= CGRectMake(0, y - kToolBarHeight - statusHeight, kbRect.size.width, kToolBarHeight);\n        inputView.frame\t= CGRectMake(inputView.frame.origin.x,\n                                     inputView.frame.origin.y,\n                                     kbRect.size.width - 3*18 - 2*50,\n                                     inputView.frame.size.height);\n\t}\n\n\t_area = CGRectMake(x, y, kbRect.size.width, kbRect.size.height);\n\t[self updateInputHidden];\n}\n#endif\n\n- (CGRect)queryArea\n{\n\treturn editView.hidden ? _area : CGRectUnion(_area, editView.frame);\n}\n\n+ (void)StartReorientation\n{\n\tif(_keyboard && _keyboard.active)\n\t{\n\t\t[CATransaction begin];\n\t\t[_keyboard hideUI];\n\t\t[CATransaction commit];\n\n\t\t// not pretty but seems like easiest way to keep \"we are rotating\" status\n\t\t_keyboard->_rotating = YES;\n\t}\n}\n\n+ (void)FinishReorientation\n{\n\tif(_keyboard && _keyboard->_rotating)\n\t{\n\t\t[CATransaction begin];\n\t\t[_keyboard showUI];\n\t\t[CATransaction commit];\n\n\t\t_keyboard->_rotating = NO;\n\t}\n}\n\n- (NSString*)getText\n{\n\tif (_canceled)\n\t\treturn initialText;\n\telse\n\t{\n#if UNITY_TVOS\n\t\treturn [textField text];\n#else\n\t\treturn _multiline ? [textView text] : [textField text];\n#endif\n\t}\n}\n\n- (void) setTextWorkaround:(id<UITextInput>)textInput text:(NSString*)newText\n{\n\tUITextPosition* begin = [textInput beginningOfDocument];\n\tUITextPosition* end = [textInput endOfDocument];\n\tUITextRange* allText = [textInput textRangeFromPosition:begin toPosition:end];\n\t[textInput setSelectedTextRange:allText];\n\t[textInput insertText:newText];\n}\n\n- (void)setText:(NSString*)newText\n{\n#if UNITY_IOS\n\t// We can't use setText on iOS7 because it does not update the undo stack.\n\t// We still prefer setText on other iOSes, because an undo operation results\n\t// in a smaller selection shown on the UI\n\tif(_ios70orNewer && !_ios80orNewer)\n\t\t[self setTextWorkaround: (_multiline ? textView : textField) text:newText];\n\n\tif(_multiline)\n\t\ttextView.text = newText;\n\telse\n\t\ttextField.text = newText;\n#else\n\ttextField.text = newText;\n#endif\n}\n\n- (void)shouldHideInput:(BOOL)hide\n{\n\tif(hide)\n\t{\n\t\tswitch(keyboardType)\n\t\t{\n\t\t\tcase UIKeyboardTypeDefault:                 hide = YES;\tbreak;\n\t\t\tcase UIKeyboardTypeASCIICapable:            hide = YES;\tbreak;\n\t\t\tcase UIKeyboardTypeNumbersAndPunctuation:   hide = YES;\tbreak;\n\t\t\tcase UIKeyboardTypeURL:                     hide = YES;\tbreak;\n\t\t\tcase UIKeyboardTypeNumberPad:               hide = NO;\tbreak;\n\t\t\tcase UIKeyboardTypePhonePad:                hide = NO;\tbreak;\n\t\t\tcase UIKeyboardTypeNamePhonePad:            hide = NO;\tbreak;\n\t\t\tcase UIKeyboardTypeEmailAddress:            hide = YES;\tbreak;\n\t\t\tdefault:                                    hide = NO;\tbreak;\n\t\t}\n\t}\n\n\t_inputHidden = hide;\n}\n\n@end\n\n\n\n//==============================================================================\n//\n//  Unity Interface:\n\nextern \"C\" void UnityKeyboard_Create(unsigned keyboardType, int autocorrection, int multiline, int secure, int alert, const char* text, const char* placeholder)\n{\n#if UNITY_TVOS\n\t// Not supported. The API for showing keyboard for editing multi-line text\n\t// is not available on tvOS\n\tmultiline = false;\n#endif\n\t\n\tstatic const UIKeyboardType keyboardTypes[] =\n\t{\n\t\tUIKeyboardTypeDefault,\n\t\tUIKeyboardTypeASCIICapable,\n\t\tUIKeyboardTypeNumbersAndPunctuation,\n\t\tUIKeyboardTypeURL,\n\t\tUIKeyboardTypeNumberPad,\n\t\tUIKeyboardTypePhonePad,\n\t\tUIKeyboardTypeNamePhonePad,\n\t\tUIKeyboardTypeEmailAddress,\n\t};\n\n\tstatic const UITextAutocorrectionType autocorrectionTypes[] =\n\t{\n\t\tUITextAutocorrectionTypeNo,\n\t\tUITextAutocorrectionTypeDefault,\n\t};\n\n\tstatic const UIKeyboardAppearance keyboardAppearances[] =\n\t{\n\t\tUIKeyboardAppearanceDefault,\n\t\tUIKeyboardAppearanceAlert,\n\t};\n\n\tKeyboardShowParam param =\n\t{\n\t\ttext, placeholder,\n\t\tkeyboardTypes[keyboardType],\n\t\tautocorrectionTypes[autocorrection],\n\t\tkeyboardAppearances[alert],\n\t\t(BOOL)multiline, (BOOL)secure\n\t};\n\n\t[[KeyboardDelegate Instance] setKeyboardParams:param];\n}\n\nextern \"C\" void UnityKeyboard_PrepareToShow()\n{\n\t[KeyboardDelegate Instance].visibleState = kPrepareToShow;\n}\n\nextern \"C\" void UnityKeyboard_Show()\n{\n\t// do not send hide if didnt create keyboard\n\t// TODO: probably assert?\n\tif(!_keyboard)\n\t\treturn;\n\n\t[[KeyboardDelegate Instance] show];\n}\n\nextern \"C\" void UnityKeyboard_Hide()\n{\n\t// do not send hide if didnt create keyboard\n\t// TODO: probably assert?\n\tif(!_keyboard)\n\t\treturn;\n\n\t[[KeyboardDelegate Instance] hide];\n}\n\nextern \"C\" void UnityKeyboard_SetText(const char* text)\n{\n\t[KeyboardDelegate Instance].text = [NSString stringWithUTF8String: text];\n}\n\nextern \"C\" NSString* UnityKeyboard_GetText()\n{\n\treturn [KeyboardDelegate Instance].text;\n}\n\nextern \"C\" int UnityKeyboard_IsActive()\n{\n\treturn (_keyboard && _keyboard.active) ? 1 : 0;\n}\n\nextern \"C\" int UnityKeyboard_IsDone()\n{\n\treturn (_keyboard && _keyboard.done) ? 1 : 0;\n}\n\nextern \"C\" int UnityKeyboard_WasCanceled()\n{\n\treturn (_keyboard && _keyboard.canceled) ? 1 : 0;\n}\n\nextern \"C\" void UnityKeyboard_SetInputHidden(int hidden)\n{\n\t_shouldHideInput\t\t= hidden;\n\t_shouldHideInputChanged\t= true;\n\n\t// update hidden status only if keyboard is on screen to avoid showing input view out of nowhere\n\tif(_keyboard && _keyboard.active)\n\t\t[_keyboard updateInputHidden];\n}\n\nextern \"C\" int UnityKeyboard_IsInputHidden()\n{\n\treturn _shouldHideInput ? 1 : 0;\n}\n\nextern \"C\" void UnityKeyboard_GetRect(float* x, float* y, float* w, float* h)\n{\n\tCGRect area = _keyboard ? _keyboard.area : CGRectMake(0,0,0,0);\n\n\t// convert to unity coord system\n\n\tfloat\tmultX\t= (float)GetMainDisplaySurface()->targetW / UnityGetGLView().bounds.size.width;\n\tfloat\tmultY\t= (float)GetMainDisplaySurface()->targetH / UnityGetGLView().bounds.size.height;\n\n\t*x = 0;\n\t*y = area.origin.y * multY;\n\t*w = area.size.width * multX;\n\t*h = area.size.height * multY;\n}\n"
		);
	}
        
    private static void EditorTGPostBuild(XCProject project)
    {
        string[] projmods = System.IO.Directory.GetFiles(
            System.IO.Path.Combine(System.IO.Path.Combine(Application.dataPath, "Standard Assets/TGSDK"), "Plugins"), "TGSDK.projmods", System.IO.SearchOption.AllDirectories);
        if(projmods.Length == 0)
        {
            Debug.LogWarning("[TGPostBuil]TGSDK.projmods not found!");
        }
        foreach (string p in projmods)
        {
            project.ApplyMod(p);
        }

        // dirty fix for "AdSupport.framework"
        PBXFileReference fileReference = project.GetFile( System.IO.Path.GetFileName( "System/Library/Frameworks/AdSupport.framework" ) );  
        if(fileReference != null)
        {
            foreach( KeyValuePair<string, PBXFrameworksBuildPhase> currentObject in project.frameworkBuildPhases ) {
                project.BuildAddFile(fileReference,currentObject,false);
            }
        }

        // project.overwriteBuildSetting("ENABLE_BITCODE", "NO", "Release");
        // project.overwriteBuildSetting("ENABLE_BITCODE", "NO", "Debug");
        project.AddOtherLinkerFlags("-ObjC");
    }
}


